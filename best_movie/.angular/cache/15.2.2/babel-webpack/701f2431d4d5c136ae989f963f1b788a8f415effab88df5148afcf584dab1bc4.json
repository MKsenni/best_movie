{"ast":null,"code":"/**\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport '../environment/dev';\nimport { createResourceUrl, unwrapResourceUrl } from '../internals/resource_url_impl';\nimport { unwrapScript } from '../internals/script_impl';\nimport { assertIsTemplateObject } from '../internals/string_literal';\n/**\n * Check whether the base url contains a valid origin,\n *\n * A string for an origin must contain only alphanumeric or any of the\n * following: `-.:`, and must not be an IP address. Remember that, as per the\n * documentation for TrustedResourceUrl, the origin must be trustworthy.\n *\n * @param base The base url that contains an origin.\n */\nfunction hasValidOrigin(base) {\n  if (!(/^https:\\/\\//.test(base) || /^\\/\\//.test(base))) {\n    return false;\n  }\n  const originStart = base.indexOf('//') + 2;\n  const originEnd = base.indexOf('/', originStart);\n  // If the base url only contains the prefix (e.g. //), or the slash\n  // for the origin is right after the prefix (e.g. ///), the origin is\n  // missing.\n  if (originEnd <= originStart) {\n    throw new Error(`Can't interpolate data in a url's origin, ` + `Please make sure to fully specify the origin, terminated with '/'.`);\n  }\n  const origin = base.substring(originStart, originEnd);\n  if (!/^[0-9a-z.:-]+$/i.test(origin)) {\n    throw new Error('The origin contains unsupported characters.');\n  }\n  if (!/^[^:]*(:[0-9]+)?$/i.test(origin)) {\n    throw new Error('Invalid port number.');\n  }\n  if (!/(^|\\.)[a-z][^.]*$/i.test(origin)) {\n    throw new Error('The top-level domain must start with a letter.');\n  }\n  return true;\n}\n/**\n * Check whether the base url contains a valid about url at its beginning.\n *\n * An about url is either exactly 'about:blank' or 'about:blank#<str>' where\n * <str> can be an arbitrary string.\n *\n * @param base The base url.\n */\nfunction isValidAboutUrl(base) {\n  if (!/^about:blank/.test(base)) {\n    return false;\n  }\n  if (base !== 'about:blank' && !/^about:blank#/.test(base)) {\n    throw new Error('The about url is invalid.');\n  }\n  return true;\n}\n/**\n * Check whether the base url contains a valid path start at its beginning.\n *\n * A valid path start is either a '/' or a '/' followed by at least one\n * character that is not '/' or '\\'.\n *\n * @param base The base url.\n */\nfunction isValidPathStart(base) {\n  if (!/^\\//.test(base)) {\n    return false;\n  }\n  if (base === '/' || base.length > 1 && base[1] !== '/' && base[1] !== '\\\\') {\n    return true;\n  }\n  throw new Error('The path start in the url is invalid.');\n}\n/**\n * Builds TrustedResourceUrl from a template literal.\n *\n * This factory is a template literal tag function. It should be called with\n * a template literal, with or without embedded expressions. For example,\n *               trustedResourceUrl`//example.com/${bar}`;\n * or\n *               trustedResourceUrl`//example.com`;\n *\n * When this function is called with a template literal without any embedded\n * expressions, the template string may contain anything as the whole URL is\n * a compile-time string constant.\n *\n * When this function is called with a template literal that contains embedded\n * expressions, the template must start with one of the following:\n * - `https://<origin>/`\n * - `//<origin>/`\n * - `/<pathStart>`\n * - `about:blank`\n * - `data:`\n *\n * `<origin>` must contain only alphanumeric or any of the following: `-.:`.\n * Remember that, as per the documentation for TrustedResourceUrl, the origin\n * must be trustworthy. An origin of \"example.com\" could be set with this\n * method, but would tie the security of your site to the security of\n * example.com. Similarly, formats that potentially cover redirects hosted\n * on a trusted origin are problematic, since that could lead to untrusted\n * origins.\n *\n * `<pathStart>` is either an empty string, or a non empty string that does not\n * start with '/' or '\\'.\n * In other words, `/<pathStart>` is either a '/' or a\n * '/' followed by at least one character that is not '/' or '\\'.\n *\n * `data:` (data URL) does not allow embedded expressions in the template\n * literal input.\n *\n * All embedded expressions are URL encoded when they are interpolated. Do not\n * embed expressions that are already URL encoded as they will be double encoded\n * by the builder.\n *\n * @param templateObj This contains the literal part of the template literal.\n * @param rest This represents the template's embedded expressions.\n */\nexport function trustedResourceUrl(templateObj, ...rest) {\n  // Check if templateObj is actually from a template literal.\n  if (process.env.NODE_ENV !== 'production') {\n    assertIsTemplateObject(templateObj, true, 'trustedResourceUrl is a template literal tag function and ' + 'can only be called as such (e.g. trustedResourceUrl`/somepath.js`)');\n  }\n  if (rest.length === 0) {\n    return createResourceUrl(templateObj[0]);\n  }\n  const base = templateObj[0].toLowerCase();\n  if (process.env.NODE_ENV !== 'production') {\n    if (/^data:/.test(base)) {\n      throw new Error('Data URLs cannot have expressions in the template literal input.');\n    }\n    if (!hasValidOrigin(base) && !isValidPathStart(base) && !isValidAboutUrl(base)) {\n      throw new Error('Trying to interpolate expressions in an unsupported url format.');\n    }\n  }\n  const urlParts = [templateObj[0]];\n  for (let i = 0; i < rest.length; i++) {\n    urlParts.push(encodeURIComponent(rest[i]));\n    urlParts.push(templateObj[i + 1]);\n  }\n  return createResourceUrl(urlParts.join(''));\n}\n/**\n * Creates a new TrustedResourceUrl with params added to the URL's search\n * parameters.\n *\n * @param params What to add to the URL. Parameters with value `null` or\n * `undefined` are skipped. Both keys and values will be encoded. Do not pass\n * pre-encoded values as this will result them being double encoded. If the\n * value is an array then the same parameter is added for every element in the\n * array.\n */\nexport function appendParams(trustedUrl, params) {\n  let url = unwrapResourceUrl(trustedUrl).toString();\n  if (/#/.test(url)) {\n    let message = '';\n    if (process.env.NODE_ENV !== 'production') {\n      message = `Found a hash in url (${url}), appending not supported`;\n    }\n    throw new Error(message);\n  }\n  let separator = /\\?/.test(url) ? '&' : '?';\n  // for-of has a big polyfill.\n  // tslint:disable-next-line:ban-iterable-foreach\n  params.forEach((value, key) => {\n    const values = value instanceof Array ? value : [value];\n    for (let i = 0; i < values.length; i++) {\n      const v = values[i];\n      if (v === null || v === undefined) {\n        continue;\n      }\n      url += separator + encodeURIComponent(key) + '=' + encodeURIComponent(String(v));\n      separator = '&';\n    }\n  });\n  return createResourceUrl(url);\n}\nconst BEFORE_FRAGMENT_REGEXP = /[^#]*/;\n/**\n * Creates a new TrustedResourceUrl based on an existing one but with the\n * addition of a fragment (the part after `#`). If the URL already has a\n * fragment, it is replaced with the new one.\n * @param fragment The fragment to add to the URL, verbatim, without the leading\n * `#`. No additional escaping is applied.\n */\nexport function replaceFragment(trustedUrl, fragment) {\n  const urlString = unwrapResourceUrl(trustedUrl).toString();\n  return createResourceUrl(BEFORE_FRAGMENT_REGEXP.exec(urlString)[0] + '#' + fragment);\n}\n/**\n * Creates a `TrustedResourceUrl` by generating a `Blob` from a\n * `SafeScript` and then calling `URL.createObjectURL` with that `Blob`.\n *\n * Caller must call `URL.revokeObjectUrl()` on the stringified url to\n * release the underlying `Blob`.\n */\nexport function blobUrlFromScript(safeScript) {\n  const scriptContent = unwrapScript(safeScript).toString();\n  const blob = new Blob([scriptContent], {\n    type: 'text/javascript'\n  });\n  return createResourceUrl(URL.createObjectURL(blob));\n}","map":{"version":3,"names":["createResourceUrl","unwrapResourceUrl","unwrapScript","assertIsTemplateObject","hasValidOrigin","base","test","originStart","indexOf","originEnd","Error","origin","substring","isValidAboutUrl","isValidPathStart","length","trustedResourceUrl","templateObj","rest","process","env","NODE_ENV","toLowerCase","urlParts","i","push","encodeURIComponent","join","appendParams","trustedUrl","params","url","toString","message","separator","forEach","value","key","values","Array","v","undefined","String","BEFORE_FRAGMENT_REGEXP","replaceFragment","fragment","urlString","exec","blobUrlFromScript","safeScript","scriptContent","blob","Blob","type","URL","createObjectURL"],"sources":["C:/Users/Acer/Desktop/best_movie/best_movie/node_modules/safevalues/builders/resource_url_builders.mjs"],"sourcesContent":["/**\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport '../environment/dev';\nimport { createResourceUrl, unwrapResourceUrl } from '../internals/resource_url_impl';\nimport { unwrapScript } from '../internals/script_impl';\nimport { assertIsTemplateObject } from '../internals/string_literal';\n/**\n * Check whether the base url contains a valid origin,\n *\n * A string for an origin must contain only alphanumeric or any of the\n * following: `-.:`, and must not be an IP address. Remember that, as per the\n * documentation for TrustedResourceUrl, the origin must be trustworthy.\n *\n * @param base The base url that contains an origin.\n */\nfunction hasValidOrigin(base) {\n    if (!(/^https:\\/\\//.test(base) || /^\\/\\//.test(base))) {\n        return false;\n    }\n    const originStart = base.indexOf('//') + 2;\n    const originEnd = base.indexOf('/', originStart);\n    // If the base url only contains the prefix (e.g. //), or the slash\n    // for the origin is right after the prefix (e.g. ///), the origin is\n    // missing.\n    if (originEnd <= originStart) {\n        throw new Error(`Can't interpolate data in a url's origin, ` +\n            `Please make sure to fully specify the origin, terminated with '/'.`);\n    }\n    const origin = base.substring(originStart, originEnd);\n    if (!/^[0-9a-z.:-]+$/i.test(origin)) {\n        throw new Error('The origin contains unsupported characters.');\n    }\n    if (!/^[^:]*(:[0-9]+)?$/i.test(origin)) {\n        throw new Error('Invalid port number.');\n    }\n    if (!/(^|\\.)[a-z][^.]*$/i.test(origin)) {\n        throw new Error('The top-level domain must start with a letter.');\n    }\n    return true;\n}\n/**\n * Check whether the base url contains a valid about url at its beginning.\n *\n * An about url is either exactly 'about:blank' or 'about:blank#<str>' where\n * <str> can be an arbitrary string.\n *\n * @param base The base url.\n */\nfunction isValidAboutUrl(base) {\n    if (!/^about:blank/.test(base)) {\n        return false;\n    }\n    if (base !== 'about:blank' && !/^about:blank#/.test(base)) {\n        throw new Error('The about url is invalid.');\n    }\n    return true;\n}\n/**\n * Check whether the base url contains a valid path start at its beginning.\n *\n * A valid path start is either a '/' or a '/' followed by at least one\n * character that is not '/' or '\\'.\n *\n * @param base The base url.\n */\nfunction isValidPathStart(base) {\n    if (!/^\\//.test(base)) {\n        return false;\n    }\n    if ((base === '/') ||\n        (base.length > 1 && base[1] !== '/' && base[1] !== '\\\\')) {\n        return true;\n    }\n    throw new Error('The path start in the url is invalid.');\n}\n/**\n * Builds TrustedResourceUrl from a template literal.\n *\n * This factory is a template literal tag function. It should be called with\n * a template literal, with or without embedded expressions. For example,\n *               trustedResourceUrl`//example.com/${bar}`;\n * or\n *               trustedResourceUrl`//example.com`;\n *\n * When this function is called with a template literal without any embedded\n * expressions, the template string may contain anything as the whole URL is\n * a compile-time string constant.\n *\n * When this function is called with a template literal that contains embedded\n * expressions, the template must start with one of the following:\n * - `https://<origin>/`\n * - `//<origin>/`\n * - `/<pathStart>`\n * - `about:blank`\n * - `data:`\n *\n * `<origin>` must contain only alphanumeric or any of the following: `-.:`.\n * Remember that, as per the documentation for TrustedResourceUrl, the origin\n * must be trustworthy. An origin of \"example.com\" could be set with this\n * method, but would tie the security of your site to the security of\n * example.com. Similarly, formats that potentially cover redirects hosted\n * on a trusted origin are problematic, since that could lead to untrusted\n * origins.\n *\n * `<pathStart>` is either an empty string, or a non empty string that does not\n * start with '/' or '\\'.\n * In other words, `/<pathStart>` is either a '/' or a\n * '/' followed by at least one character that is not '/' or '\\'.\n *\n * `data:` (data URL) does not allow embedded expressions in the template\n * literal input.\n *\n * All embedded expressions are URL encoded when they are interpolated. Do not\n * embed expressions that are already URL encoded as they will be double encoded\n * by the builder.\n *\n * @param templateObj This contains the literal part of the template literal.\n * @param rest This represents the template's embedded expressions.\n */\nexport function trustedResourceUrl(templateObj, ...rest) {\n    // Check if templateObj is actually from a template literal.\n    if (process.env.NODE_ENV !== 'production') {\n        assertIsTemplateObject(templateObj, true, 'trustedResourceUrl is a template literal tag function and ' +\n            'can only be called as such (e.g. trustedResourceUrl`/somepath.js`)');\n    }\n    if (rest.length === 0) {\n        return createResourceUrl(templateObj[0]);\n    }\n    const base = templateObj[0].toLowerCase();\n    if (process.env.NODE_ENV !== 'production') {\n        if (/^data:/.test(base)) {\n            throw new Error('Data URLs cannot have expressions in the template literal input.');\n        }\n        if (!hasValidOrigin(base) && !isValidPathStart(base) &&\n            !isValidAboutUrl(base)) {\n            throw new Error('Trying to interpolate expressions in an unsupported url format.');\n        }\n    }\n    const urlParts = [templateObj[0]];\n    for (let i = 0; i < rest.length; i++) {\n        urlParts.push(encodeURIComponent(rest[i]));\n        urlParts.push(templateObj[i + 1]);\n    }\n    return createResourceUrl(urlParts.join(''));\n}\n/**\n * Creates a new TrustedResourceUrl with params added to the URL's search\n * parameters.\n *\n * @param params What to add to the URL. Parameters with value `null` or\n * `undefined` are skipped. Both keys and values will be encoded. Do not pass\n * pre-encoded values as this will result them being double encoded. If the\n * value is an array then the same parameter is added for every element in the\n * array.\n */\nexport function appendParams(trustedUrl, params) {\n    let url = unwrapResourceUrl(trustedUrl).toString();\n    if (/#/.test(url)) {\n        let message = '';\n        if (process.env.NODE_ENV !== 'production') {\n            message = `Found a hash in url (${url}), appending not supported`;\n        }\n        throw new Error(message);\n    }\n    let separator = /\\?/.test(url) ? '&' : '?';\n    // for-of has a big polyfill.\n    // tslint:disable-next-line:ban-iterable-foreach\n    params.forEach((value, key) => {\n        const values = (value instanceof Array) ? value : [value];\n        for (let i = 0; i < values.length; i++) {\n            const v = values[i];\n            if (v === null || v === undefined) {\n                continue;\n            }\n            url += separator + encodeURIComponent(key) + '=' +\n                encodeURIComponent(String(v));\n            separator = '&';\n        }\n    });\n    return createResourceUrl(url);\n}\nconst BEFORE_FRAGMENT_REGEXP = /[^#]*/;\n/**\n * Creates a new TrustedResourceUrl based on an existing one but with the\n * addition of a fragment (the part after `#`). If the URL already has a\n * fragment, it is replaced with the new one.\n * @param fragment The fragment to add to the URL, verbatim, without the leading\n * `#`. No additional escaping is applied.\n */\nexport function replaceFragment(trustedUrl, fragment) {\n    const urlString = unwrapResourceUrl(trustedUrl).toString();\n    return createResourceUrl(BEFORE_FRAGMENT_REGEXP.exec(urlString)[0] + '#' + fragment);\n}\n/**\n * Creates a `TrustedResourceUrl` by generating a `Blob` from a\n * `SafeScript` and then calling `URL.createObjectURL` with that `Blob`.\n *\n * Caller must call `URL.revokeObjectUrl()` on the stringified url to\n * release the underlying `Blob`.\n */\nexport function blobUrlFromScript(safeScript) {\n    const scriptContent = unwrapScript(safeScript).toString();\n    const blob = new Blob([scriptContent], { type: 'text/javascript' });\n    return createResourceUrl(URL.createObjectURL(blob));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}