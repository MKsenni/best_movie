{"ast":null,"code":"/**\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @fileoverview This contains safe wrappers for properties that aren't specific\n * to one kind of HTMLElement (like innerHTML), plus other setters and functions\n * that are not tied to elements (like location.href or Worker constructor).\n */\nimport { unwrapAttributePrefix } from '../../internals/attribute_impl';\nimport { unwrapHtml } from '../../internals/html_impl';\nimport { unwrapStyle } from '../../internals/style_impl';\n/**\n * Safely set {@link Element.innerHTML} on a given ShadowRoot or Element which\n * may not be a `<script>` element or a `<style>` element.\n */\nexport function setInnerHtml(elOrRoot, v) {\n  if (isElement(elOrRoot)) {\n    throwIfScriptOrStyle(elOrRoot);\n  }\n  elOrRoot.innerHTML = unwrapHtml(v);\n}\n/**\n * Safely set {@link Element.outerHTML} for the given Element.\n */\nexport function setOuterHtml(e, v) {\n  const parent = e.parentElement;\n  if (parent !== null) {\n    throwIfScriptOrStyle(parent);\n  }\n  e.outerHTML = unwrapHtml(v);\n}\n/**\n * Set `ElementCSSInlineStyle.cssText` for the given `ElementCSSInlineStyle`.\n */\nexport function setCssText(e, v) {\n  e.style.cssText = unwrapStyle(v);\n}\n/**\n * Safely call {@link Element.insertAdjacentHTML} for the given Element.\n */\nexport function insertAdjacentHtml(element, position, v) {\n  const tagContext = position === 'beforebegin' || position === 'afterend' ? element.parentElement : element;\n  if (tagContext !== null) {\n    throwIfScriptOrStyle(tagContext);\n  }\n  element.insertAdjacentHTML(position, unwrapHtml(v));\n}\n/**\n * Given a set of known-to-be-safe prefixes (e.g., \"data-\", \"aria-\", \"js\"),\n * return a setter function that allows you to set attributes on an element,\n * as long as the names of the attributes to be set has one of the prefixes.\n *\n * The returned setter ensures that setting any dangerous attribute, e.g.,\n * \"src\", \"href\" will cause an exception. This is intended to be used as the\n * safe alterantive of `Element#setAttribute`, when applications need to set\n * attributes that do not have security implications and do not have a\n * corresponding DOM property.\n */\nexport function buildPrefixedAttributeSetter(prefix, ...otherPrefixes) {\n  const prefixes = [prefix, ...otherPrefixes];\n  return (e, attr, value) => {\n    setPrefixedAttribute(prefixes, e, attr, value);\n  };\n}\n/**\n * The safe alternative to Element#setAttribute. The function takes a list of\n * `SafeAttributePrefix`, making developer intention explicit. The attribute\n * to be set must has one of the safe prefixes, otherwise the function throws\n * an Error.\n */\nexport function setPrefixedAttribute(attrPrefixes, e, attr, value) {\n  if (attrPrefixes.length === 0) {\n    throw new Error('No prefixes are provided');\n  }\n  const prefixes = attrPrefixes.map(s => unwrapAttributePrefix(s));\n  const attrLower = attr.toLowerCase();\n  if (prefixes.every(p => attrLower.indexOf(p) !== 0)) {\n    throw new Error(`Attribute \"${attr}\" does not match any of the allowed prefixes.`);\n  }\n  e.setAttribute(attr, value);\n}\nfunction throwIfScriptOrStyle(element) {\n  if (element.tagName.toLowerCase() === 'script') {\n    throw new Error('Use setTextContent with a SafeScript.');\n  } else if (element.tagName.toLowerCase() === 'style') {\n    throw new Error('Use setTextContent with a SafeStyleSheet.');\n  }\n}\nfunction isElement(elOrRoot) {\n  return elOrRoot.tagName !== undefined;\n}","map":{"version":3,"names":["unwrapAttributePrefix","unwrapHtml","unwrapStyle","setInnerHtml","elOrRoot","v","isElement","throwIfScriptOrStyle","innerHTML","setOuterHtml","e","parent","parentElement","outerHTML","setCssText","style","cssText","insertAdjacentHtml","element","position","tagContext","insertAdjacentHTML","buildPrefixedAttributeSetter","prefix","otherPrefixes","prefixes","attr","value","setPrefixedAttribute","attrPrefixes","length","Error","map","s","attrLower","toLowerCase","every","p","indexOf","setAttribute","tagName","undefined"],"sources":["C:/Users/Acer/Desktop/best_movie/best_movie/node_modules/safevalues/dom/elements/element.mjs"],"sourcesContent":["/**\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @fileoverview This contains safe wrappers for properties that aren't specific\n * to one kind of HTMLElement (like innerHTML), plus other setters and functions\n * that are not tied to elements (like location.href or Worker constructor).\n */\nimport { unwrapAttributePrefix } from '../../internals/attribute_impl';\nimport { unwrapHtml } from '../../internals/html_impl';\nimport { unwrapStyle } from '../../internals/style_impl';\n/**\n * Safely set {@link Element.innerHTML} on a given ShadowRoot or Element which\n * may not be a `<script>` element or a `<style>` element.\n */\nexport function setInnerHtml(elOrRoot, v) {\n    if (isElement(elOrRoot)) {\n        throwIfScriptOrStyle(elOrRoot);\n    }\n    elOrRoot.innerHTML = unwrapHtml(v);\n}\n/**\n * Safely set {@link Element.outerHTML} for the given Element.\n */\nexport function setOuterHtml(e, v) {\n    const parent = e.parentElement;\n    if (parent !== null) {\n        throwIfScriptOrStyle(parent);\n    }\n    e.outerHTML = unwrapHtml(v);\n}\n/**\n * Set `ElementCSSInlineStyle.cssText` for the given `ElementCSSInlineStyle`.\n */\nexport function setCssText(e, v) {\n    e.style.cssText = unwrapStyle(v);\n}\n/**\n * Safely call {@link Element.insertAdjacentHTML} for the given Element.\n */\nexport function insertAdjacentHtml(element, position, v) {\n    const tagContext = (position === 'beforebegin' || position === 'afterend') ?\n        element.parentElement :\n        element;\n    if (tagContext !== null) {\n        throwIfScriptOrStyle(tagContext);\n    }\n    element.insertAdjacentHTML(position, unwrapHtml(v));\n}\n/**\n * Given a set of known-to-be-safe prefixes (e.g., \"data-\", \"aria-\", \"js\"),\n * return a setter function that allows you to set attributes on an element,\n * as long as the names of the attributes to be set has one of the prefixes.\n *\n * The returned setter ensures that setting any dangerous attribute, e.g.,\n * \"src\", \"href\" will cause an exception. This is intended to be used as the\n * safe alterantive of `Element#setAttribute`, when applications need to set\n * attributes that do not have security implications and do not have a\n * corresponding DOM property.\n */\nexport function buildPrefixedAttributeSetter(prefix, ...otherPrefixes) {\n    const prefixes = [prefix, ...otherPrefixes];\n    return (e, attr, value) => {\n        setPrefixedAttribute(prefixes, e, attr, value);\n    };\n}\n/**\n * The safe alternative to Element#setAttribute. The function takes a list of\n * `SafeAttributePrefix`, making developer intention explicit. The attribute\n * to be set must has one of the safe prefixes, otherwise the function throws\n * an Error.\n */\nexport function setPrefixedAttribute(attrPrefixes, e, attr, value) {\n    if (attrPrefixes.length === 0) {\n        throw new Error('No prefixes are provided');\n    }\n    const prefixes = attrPrefixes.map(s => unwrapAttributePrefix(s));\n    const attrLower = attr.toLowerCase();\n    if (prefixes.every(p => attrLower.indexOf(p) !== 0)) {\n        throw new Error(`Attribute \"${attr}\" does not match any of the allowed prefixes.`);\n    }\n    e.setAttribute(attr, value);\n}\nfunction throwIfScriptOrStyle(element) {\n    if (element.tagName.toLowerCase() === 'script') {\n        throw new Error('Use setTextContent with a SafeScript.');\n    }\n    else if (element.tagName.toLowerCase() === 'style') {\n        throw new Error('Use setTextContent with a SafeStyleSheet.');\n    }\n}\nfunction isElement(elOrRoot) {\n    return elOrRoot.tagName !== undefined;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}