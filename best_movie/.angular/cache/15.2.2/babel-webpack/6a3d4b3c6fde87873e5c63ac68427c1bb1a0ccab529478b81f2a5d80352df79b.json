{"ast":null,"code":"import _defineProperty from \"C:/Users/Acer/Desktop/best_movie/best_movie/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport '../../environment/dev';\nimport { createHtml } from '../../internals/html_impl';\n/* g3_import_pure from '../../internals/pure' */\nimport { ensureTokenIsValid, secretToken } from '../../internals/secrets';\nimport { restrictivelySanitizeUrl } from '../url_sanitizer';\nimport { createInertFragment } from './inert_fragment';\nimport { getNodeName, isElement, isText } from './no_clobber';\nimport { defaultSanitizerTable } from './sanitizer_table/default_sanitizer_table';\nimport { AttributePolicyAction } from './sanitizer_table/sanitizer_table';\n/** Implementation for `HtmlSanitizer` */\nexport class HtmlSanitizerImpl {\n  constructor(sanitizerTable, token) {\n    _defineProperty(this, \"sanitizerTable\", void 0);\n    _defineProperty(this, \"changes\", []);\n    this.sanitizerTable = sanitizerTable;\n    ensureTokenIsValid(token);\n  }\n  sanitizeAssertUnchanged(html) {\n    this.changes = [];\n    const sanitizedHtml = this.sanitize(html);\n    if (this.changes.length !== 0) {\n      let message = '';\n      if (process.env.NODE_ENV !== 'production') {\n        message = `Unexpected change to HTML value as a result of sanitization. ` + `Input: \"${html}\", sanitized output: \"${sanitizedHtml}\"\\n` + `List of changes:${this.changes.join('\\n')}`;\n      }\n      throw new Error(message);\n    }\n    return sanitizedHtml;\n  }\n  sanitize(html) {\n    const fakeRoot = document.createElement('span');\n    fakeRoot.appendChild(this.sanitizeToFragment(html));\n    // XML serialization is preferred over HTML serialization as it is\n    // stricter and makes sure all attributes are properly escaped, avoiding\n    // cases where the tree might mutate when parsed again later due to the\n    // complexities of the HTML parsing algorithm\n    let serializedNewTree = new XMLSerializer().serializeToString(fakeRoot);\n    // We remove the outer most element as this is the span node created as\n    // the root for the sanitized tree and contains a spurious xmlns attribute\n    // from the XML serialization step.\n    serializedNewTree = serializedNewTree.slice(serializedNewTree.indexOf('>') + 1, serializedNewTree.lastIndexOf('</'));\n    return createHtml(serializedNewTree);\n  }\n  sanitizeToFragment(html) {\n    const dirtyFragment = createInertFragment(html);\n    const treeWalker = document.createTreeWalker(dirtyFragment, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT,\n    // IE10 and IE11 won't accept a proper `NodeFilter` interface, and\n    // expect the filtering function to be passed directly. It seems that\n    // other browsers also do not mind getting the function directly. see\n    // https://stackoverflow.com/q/38245898\n    n => this.nodeFilter(n),\n    // @ts-ignore: error TS2554: Expected 1-3 arguments, but got 4.\n    false);\n    // `nextNode` is called so we skip the root `DocumentFragment`.\n    let currentNode = treeWalker.nextNode();\n    // We create a root element to attach all the children of the body to. We\n    // use div as it as a semantic-free, generic container and does not\n    // represent anything. This is removed when we serialize the tree back\n    // into a string.\n    const sanitizedFragment = document.createDocumentFragment();\n    let sanitizedParent = sanitizedFragment;\n    while (currentNode !== null) {\n      let sanitizedNode;\n      if (isText(currentNode)) {\n        sanitizedNode = this.sanitizeTextNode(currentNode);\n      } else if (isElement(currentNode)) {\n        sanitizedNode = this.sanitizeElementNode(currentNode);\n      } else {\n        throw new Error('Node is not of type text or element');\n      }\n      sanitizedParent.appendChild(sanitizedNode);\n      // Advance iterator while keeping track of the sanitized parent for the\n      // current node\n      currentNode = treeWalker.firstChild();\n      if (currentNode) {\n        sanitizedParent = sanitizedNode;\n      } else {\n        while (!(currentNode = treeWalker.nextSibling())) {\n          if (!(currentNode = treeWalker.parentNode())) {\n            break;\n          }\n          sanitizedParent = sanitizedParent.parentNode;\n        }\n      }\n    }\n    return sanitizedFragment;\n  }\n  sanitizeTextNode(textNode) {\n    return document.createTextNode(textNode.data);\n  }\n  sanitizeElementNode(elementNode) {\n    const elementName = getNodeName(elementNode);\n    const newNode = document.createElement(elementName);\n    const dirtyAttributes = elementNode.attributes;\n    for (const {\n      name,\n      value\n    } of dirtyAttributes) {\n      const policy = this.sanitizerTable.getAttributePolicy(name, elementName);\n      if (!this.satisfiesAllConditions(policy.conditions, dirtyAttributes)) {\n        this.recordChange(`Not all conditions satisfied for attribute: ${name}.`);\n        continue;\n      }\n      switch (policy.policyAction) {\n        case AttributePolicyAction.KEEP:\n          newNode.setAttribute(name, value);\n          break;\n        case AttributePolicyAction.KEEP_AND_SANITIZE_URL:\n          const sanitizedAttrUrl = restrictivelySanitizeUrl(value);\n          if (sanitizedAttrUrl !== value) {\n            this.recordChange(`Url in attribute ${name} was modified during sanitization. Original url:\"${value}\" was sanitized to: \"${sanitizedAttrUrl}\"`);\n          }\n          newNode.setAttribute(name, sanitizedAttrUrl);\n          break;\n        case AttributePolicyAction.KEEP_AND_NORMALIZE:\n          // We don't consider changing the case of an attribute value to be a\n          // semantic change\n          newNode.setAttribute(name, value.toLowerCase());\n          break;\n        case AttributePolicyAction.KEEP_AND_SANITIZE_STYLE:\n          newNode.setAttribute(name, value);\n          break;\n        case AttributePolicyAction.DROP:\n          this.recordChange(`Attribute: ${name} was dropped`);\n          break;\n        default:\n          checkExhaustive(policy.policyAction, 'Unhandled AttributePolicyAction case');\n      }\n    }\n    return newNode;\n  }\n  nodeFilter(node) {\n    if (isText(node)) {\n      return NodeFilter.FILTER_ACCEPT;\n    } else if (!isElement(node)) {\n      // Getting a node that is neither an `Element` or a `Text` node. This is\n      // likely due to something that is not supposed to be an element in user\n      // code but recognized as such by the TreeWalker (e.g. a polyfill for\n      // other kind of nodes). Since we can't recognize it as an element, we\n      // drop the node, but we don't record it as a meaningful change.\n      return NodeFilter.FILTER_REJECT;\n    }\n    const nodeName = getNodeName(node);\n    if (nodeName === null) {\n      this.recordChange(`Node name was null for node: ${node}`);\n      return NodeFilter.FILTER_REJECT;\n    }\n    if (this.sanitizerTable.isAllowedElement(nodeName)) {\n      return NodeFilter.FILTER_ACCEPT;\n    }\n    this.recordChange(`Element: ${nodeName} was dropped`);\n    return NodeFilter.FILTER_REJECT;\n  }\n  recordChange(errorMessage) {\n    if (process.env.NODE_ENV !== 'production') {\n      this.changes.push(errorMessage);\n    } else if (this.changes.length === 0) {\n      this.changes.push('');\n    }\n  }\n  satisfiesAllConditions(conditions, attrs) {\n    if (!conditions) {\n      return true;\n    }\n    for (const [attrName, expectedValues] of conditions) {\n      const value = attrs.getNamedItem(attrName)?.value;\n      if (value && !expectedValues.has(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nconst defaultHtmlSanitizer = /* #__PURE__ */(() => new HtmlSanitizerImpl(defaultSanitizerTable, secretToken))();\n/** Sanitizes untrusted html using the default sanitizer configuration. */\nexport function sanitizeHtml(html) {\n  return defaultHtmlSanitizer.sanitize(html);\n}\n/**\n * Sanitizes untrusted html using the default sanitizer configuration. Throws\n * an error if the html was changed.\n */\nexport function sanitizeHtmlAssertUnchanged(html) {\n  return defaultHtmlSanitizer.sanitizeAssertUnchanged(html);\n}\n/**\n * Sanitizes untrusted html using the default sanitizer configuration. Throws\n * an error if the html was changed.\n */\nexport function sanitizeHtmlToFragment(html) {\n  return defaultHtmlSanitizer.sanitizeToFragment(html);\n}\nfunction checkExhaustive(value, msg = `unexpected value ${value}!`) {\n  throw new Error(msg);\n}","map":{"version":3,"names":["createHtml","ensureTokenIsValid","secretToken","restrictivelySanitizeUrl","createInertFragment","getNodeName","isElement","isText","defaultSanitizerTable","AttributePolicyAction","HtmlSanitizerImpl","constructor","sanitizerTable","token","sanitizeAssertUnchanged","html","changes","sanitizedHtml","sanitize","length","message","process","env","NODE_ENV","join","Error","fakeRoot","document","createElement","appendChild","sanitizeToFragment","serializedNewTree","XMLSerializer","serializeToString","slice","indexOf","lastIndexOf","dirtyFragment","treeWalker","createTreeWalker","NodeFilter","SHOW_ELEMENT","SHOW_TEXT","n","nodeFilter","currentNode","nextNode","sanitizedFragment","createDocumentFragment","sanitizedParent","sanitizedNode","sanitizeTextNode","sanitizeElementNode","firstChild","nextSibling","parentNode","textNode","createTextNode","data","elementNode","elementName","newNode","dirtyAttributes","attributes","name","value","policy","getAttributePolicy","satisfiesAllConditions","conditions","recordChange","policyAction","KEEP","setAttribute","KEEP_AND_SANITIZE_URL","sanitizedAttrUrl","KEEP_AND_NORMALIZE","toLowerCase","KEEP_AND_SANITIZE_STYLE","DROP","checkExhaustive","node","FILTER_ACCEPT","FILTER_REJECT","nodeName","isAllowedElement","errorMessage","push","attrs","attrName","expectedValues","getNamedItem","has","defaultHtmlSanitizer","sanitizeHtml","sanitizeHtmlAssertUnchanged","sanitizeHtmlToFragment","msg"],"sources":["C:/Users/Acer/Desktop/best_movie/best_movie/node_modules/safevalues/builders/html_sanitizer/html_sanitizer.mjs"],"sourcesContent":["/**\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport '../../environment/dev';\nimport { createHtml } from '../../internals/html_impl';\n/* g3_import_pure from '../../internals/pure' */\nimport { ensureTokenIsValid, secretToken } from '../../internals/secrets';\nimport { restrictivelySanitizeUrl } from '../url_sanitizer';\nimport { createInertFragment } from './inert_fragment';\nimport { getNodeName, isElement, isText } from './no_clobber';\nimport { defaultSanitizerTable } from './sanitizer_table/default_sanitizer_table';\nimport { AttributePolicyAction } from './sanitizer_table/sanitizer_table';\n/** Implementation for `HtmlSanitizer` */\nexport class HtmlSanitizerImpl {\n    sanitizerTable;\n    changes = [];\n    constructor(sanitizerTable, token) {\n        this.sanitizerTable = sanitizerTable;\n        ensureTokenIsValid(token);\n    }\n    sanitizeAssertUnchanged(html) {\n        this.changes = [];\n        const sanitizedHtml = this.sanitize(html);\n        if (this.changes.length !== 0) {\n            let message = '';\n            if (process.env.NODE_ENV !== 'production') {\n                message =\n                    `Unexpected change to HTML value as a result of sanitization. ` +\n                        `Input: \"${html}\", sanitized output: \"${sanitizedHtml}\"\\n` +\n                        `List of changes:${this.changes.join('\\n')}`;\n            }\n            throw new Error(message);\n        }\n        return sanitizedHtml;\n    }\n    sanitize(html) {\n        const fakeRoot = document.createElement('span');\n        fakeRoot.appendChild(this.sanitizeToFragment(html));\n        // XML serialization is preferred over HTML serialization as it is\n        // stricter and makes sure all attributes are properly escaped, avoiding\n        // cases where the tree might mutate when parsed again later due to the\n        // complexities of the HTML parsing algorithm\n        let serializedNewTree = new XMLSerializer().serializeToString(fakeRoot);\n        // We remove the outer most element as this is the span node created as\n        // the root for the sanitized tree and contains a spurious xmlns attribute\n        // from the XML serialization step.\n        serializedNewTree = serializedNewTree.slice(serializedNewTree.indexOf('>') + 1, serializedNewTree.lastIndexOf('</'));\n        return createHtml(serializedNewTree);\n    }\n    sanitizeToFragment(html) {\n        const dirtyFragment = createInertFragment(html);\n        const treeWalker = document.createTreeWalker(dirtyFragment, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, \n        // IE10 and IE11 won't accept a proper `NodeFilter` interface, and\n        // expect the filtering function to be passed directly. It seems that\n        // other browsers also do not mind getting the function directly. see\n        // https://stackoverflow.com/q/38245898\n        ((n) => this.nodeFilter(n)), \n        // @ts-ignore: error TS2554: Expected 1-3 arguments, but got 4.\n        false);\n        // `nextNode` is called so we skip the root `DocumentFragment`.\n        let currentNode = treeWalker.nextNode();\n        // We create a root element to attach all the children of the body to. We\n        // use div as it as a semantic-free, generic container and does not\n        // represent anything. This is removed when we serialize the tree back\n        // into a string.\n        const sanitizedFragment = document.createDocumentFragment();\n        let sanitizedParent = sanitizedFragment;\n        while (currentNode !== null) {\n            let sanitizedNode;\n            if (isText(currentNode)) {\n                sanitizedNode = this.sanitizeTextNode(currentNode);\n            }\n            else if (isElement(currentNode)) {\n                sanitizedNode = this.sanitizeElementNode(currentNode);\n            }\n            else {\n                throw new Error('Node is not of type text or element');\n            }\n            sanitizedParent.appendChild(sanitizedNode);\n            // Advance iterator while keeping track of the sanitized parent for the\n            // current node\n            currentNode = treeWalker.firstChild();\n            if (currentNode) {\n                sanitizedParent = sanitizedNode;\n            }\n            else {\n                while (!(currentNode = treeWalker.nextSibling())) {\n                    if (!(currentNode = treeWalker.parentNode())) {\n                        break;\n                    }\n                    sanitizedParent = sanitizedParent.parentNode;\n                }\n            }\n        }\n        return sanitizedFragment;\n    }\n    sanitizeTextNode(textNode) {\n        return document.createTextNode(textNode.data);\n    }\n    sanitizeElementNode(elementNode) {\n        const elementName = getNodeName(elementNode);\n        const newNode = document.createElement(elementName);\n        const dirtyAttributes = elementNode.attributes;\n        for (const { name, value } of dirtyAttributes) {\n            const policy = this.sanitizerTable.getAttributePolicy(name, elementName);\n            if (!this.satisfiesAllConditions(policy.conditions, dirtyAttributes)) {\n                this.recordChange(`Not all conditions satisfied for attribute: ${name}.`);\n                continue;\n            }\n            switch (policy.policyAction) {\n                case AttributePolicyAction.KEEP:\n                    newNode.setAttribute(name, value);\n                    break;\n                case AttributePolicyAction.KEEP_AND_SANITIZE_URL:\n                    const sanitizedAttrUrl = restrictivelySanitizeUrl(value);\n                    if (sanitizedAttrUrl !== value) {\n                        this.recordChange(`Url in attribute ${name} was modified during sanitization. Original url:\"${value}\" was sanitized to: \"${sanitizedAttrUrl}\"`);\n                    }\n                    newNode.setAttribute(name, sanitizedAttrUrl);\n                    break;\n                case AttributePolicyAction.KEEP_AND_NORMALIZE:\n                    // We don't consider changing the case of an attribute value to be a\n                    // semantic change\n                    newNode.setAttribute(name, value.toLowerCase());\n                    break;\n                case AttributePolicyAction.KEEP_AND_SANITIZE_STYLE:\n                    newNode.setAttribute(name, value);\n                    break;\n                case AttributePolicyAction.DROP:\n                    this.recordChange(`Attribute: ${name} was dropped`);\n                    break;\n                default:\n                    checkExhaustive(policy.policyAction, 'Unhandled AttributePolicyAction case');\n            }\n        }\n        return newNode;\n    }\n    nodeFilter(node) {\n        if (isText(node)) {\n            return NodeFilter.FILTER_ACCEPT;\n        }\n        else if (!isElement(node)) {\n            // Getting a node that is neither an `Element` or a `Text` node. This is\n            // likely due to something that is not supposed to be an element in user\n            // code but recognized as such by the TreeWalker (e.g. a polyfill for\n            // other kind of nodes). Since we can't recognize it as an element, we\n            // drop the node, but we don't record it as a meaningful change.\n            return NodeFilter.FILTER_REJECT;\n        }\n        const nodeName = getNodeName(node);\n        if (nodeName === null) {\n            this.recordChange(`Node name was null for node: ${node}`);\n            return NodeFilter.FILTER_REJECT;\n        }\n        if (this.sanitizerTable.isAllowedElement(nodeName)) {\n            return NodeFilter.FILTER_ACCEPT;\n        }\n        this.recordChange(`Element: ${nodeName} was dropped`);\n        return NodeFilter.FILTER_REJECT;\n    }\n    recordChange(errorMessage) {\n        if (process.env.NODE_ENV !== 'production') {\n            this.changes.push(errorMessage);\n        }\n        else if (this.changes.length === 0) {\n            this.changes.push('');\n        }\n    }\n    satisfiesAllConditions(conditions, attrs) {\n        if (!conditions) {\n            return true;\n        }\n        for (const [attrName, expectedValues] of conditions) {\n            const value = attrs.getNamedItem(attrName)?.value;\n            if (value && !expectedValues.has(value)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nconst defaultHtmlSanitizer = \n/* #__PURE__ */ (() => new HtmlSanitizerImpl(defaultSanitizerTable, secretToken))();\n/** Sanitizes untrusted html using the default sanitizer configuration. */\nexport function sanitizeHtml(html) {\n    return defaultHtmlSanitizer.sanitize(html);\n}\n/**\n * Sanitizes untrusted html using the default sanitizer configuration. Throws\n * an error if the html was changed.\n */\nexport function sanitizeHtmlAssertUnchanged(html) {\n    return defaultHtmlSanitizer.sanitizeAssertUnchanged(html);\n}\n/**\n * Sanitizes untrusted html using the default sanitizer configuration. Throws\n * an error if the html was changed.\n */\nexport function sanitizeHtmlToFragment(html) {\n    return defaultHtmlSanitizer.sanitizeToFragment(html);\n}\nfunction checkExhaustive(value, msg = `unexpected value ${value}!`) {\n    throw new Error(msg);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}