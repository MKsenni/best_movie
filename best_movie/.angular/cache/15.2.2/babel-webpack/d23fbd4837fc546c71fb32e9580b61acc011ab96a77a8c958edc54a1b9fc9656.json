{"ast":null,"code":"/**\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @fileoverview Provides functions to enforce the SafeUrl contract at the sink\n * level.\n */\nimport '../environment/dev';\nfunction extractScheme(url) {\n  let parsedUrl;\n  try {\n    parsedUrl = new URL(url);\n  } catch (e) {\n    // According to https://url.spec.whatwg.org/#constructors, the URL\n    // constructor with one parameter throws if `url` is not absolute. In this\n    // case, we are sure that no explicit scheme (javascript: ) is set.\n    // This can also be a URL parsing error, but in this case the URL won't be\n    // run anyway.\n    return 'https:';\n  }\n  return parsedUrl.protocol;\n}\n// We can't use an ES6 Set here because gws somehow depends on this code and\n// doesn't want to pay the cost of a polyfill.\nconst ALLOWED_SCHEMES = ['data:', 'http:', 'https:', 'mailto:', 'ftp:'];\n/**\n * Checks that the URL scheme is not javascript.\n * The URL parsing relies on the URL API in browsers that support it.\n * @param url The URL to sanitize for a SafeUrl sink.\n * @return undefined if url has a javascript: scheme, the original URL\n *     otherwise.\n */\nexport function sanitizeJavascriptUrl(url) {\n  const parsedScheme = extractScheme(url);\n  if (parsedScheme === 'javascript:') {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error(`A URL with content '${url}' was sanitized away.`);\n    }\n    return undefined;\n  }\n  return url;\n}\n/**\n * Adapter to sanitize string URLs in DOM sink wrappers.\n * @return undefined if the URL was sanitized.\n */\nexport function unwrapUrlOrSanitize(url) {\n  return sanitizeJavascriptUrl(url);\n}\n/**\n * Sanitizes a URL restrictively.\n * This sanitizer protects against XSS and potentially other uncommon and\n * undesirable schemes that an attacker could use for e.g. phishing (tel:,\n * callto: ssh: etc schemes). This sanitizer is primarily meant to be used by\n * the HTML sanitizer.\n */\nexport function restrictivelySanitizeUrl(url) {\n  const parsedScheme = extractScheme(url);\n  if (parsedScheme !== undefined && ALLOWED_SCHEMES.indexOf(parsedScheme.toLowerCase()) !== -1) {\n    return url;\n  }\n  return 'about:invalid#zClosurez';\n}","map":{"version":3,"names":["extractScheme","url","parsedUrl","URL","e","protocol","ALLOWED_SCHEMES","sanitizeJavascriptUrl","parsedScheme","process","env","NODE_ENV","console","error","undefined","unwrapUrlOrSanitize","restrictivelySanitizeUrl","indexOf","toLowerCase"],"sources":["C:/Users/Acer/Desktop/best_movie/best_movie/node_modules/safevalues/builders/url_sanitizer.mjs"],"sourcesContent":["/**\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @fileoverview Provides functions to enforce the SafeUrl contract at the sink\n * level.\n */\nimport '../environment/dev';\nfunction extractScheme(url) {\n    let parsedUrl;\n    try {\n        parsedUrl = new URL(url);\n    }\n    catch (e) {\n        // According to https://url.spec.whatwg.org/#constructors, the URL\n        // constructor with one parameter throws if `url` is not absolute. In this\n        // case, we are sure that no explicit scheme (javascript: ) is set.\n        // This can also be a URL parsing error, but in this case the URL won't be\n        // run anyway.\n        return 'https:';\n    }\n    return parsedUrl.protocol;\n}\n// We can't use an ES6 Set here because gws somehow depends on this code and\n// doesn't want to pay the cost of a polyfill.\nconst ALLOWED_SCHEMES = ['data:', 'http:', 'https:', 'mailto:', 'ftp:'];\n/**\n * Checks that the URL scheme is not javascript.\n * The URL parsing relies on the URL API in browsers that support it.\n * @param url The URL to sanitize for a SafeUrl sink.\n * @return undefined if url has a javascript: scheme, the original URL\n *     otherwise.\n */\nexport function sanitizeJavascriptUrl(url) {\n    const parsedScheme = extractScheme(url);\n    if (parsedScheme === 'javascript:') {\n        if (process.env.NODE_ENV !== 'production') {\n            console.error(`A URL with content '${url}' was sanitized away.`);\n        }\n        return undefined;\n    }\n    return url;\n}\n/**\n * Adapter to sanitize string URLs in DOM sink wrappers.\n * @return undefined if the URL was sanitized.\n */\nexport function unwrapUrlOrSanitize(url) {\n    return sanitizeJavascriptUrl(url);\n}\n/**\n * Sanitizes a URL restrictively.\n * This sanitizer protects against XSS and potentially other uncommon and\n * undesirable schemes that an attacker could use for e.g. phishing (tel:,\n * callto: ssh: etc schemes). This sanitizer is primarily meant to be used by\n * the HTML sanitizer.\n */\nexport function restrictivelySanitizeUrl(url) {\n    const parsedScheme = extractScheme(url);\n    if (parsedScheme !== undefined &&\n        ALLOWED_SCHEMES.indexOf(parsedScheme.toLowerCase()) !== -1) {\n        return url;\n    }\n    return 'about:invalid#zClosurez';\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,oBAAoB;AAC3B,SAASA,aAAa,CAACC,GAAG,EAAE;EACxB,IAAIC,SAAS;EACb,IAAI;IACAA,SAAS,GAAG,IAAIC,GAAG,CAACF,GAAG,CAAC;EAC5B,CAAC,CACD,OAAOG,CAAC,EAAE;IACN;IACA;IACA;IACA;IACA;IACA,OAAO,QAAQ;EACnB;EACA,OAAOF,SAAS,CAACG,QAAQ;AAC7B;AACA;AACA;AACA,MAAMC,eAAe,GAAG,CAAC,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,CAAC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,qBAAqB,CAACN,GAAG,EAAE;EACvC,MAAMO,YAAY,GAAGR,aAAa,CAACC,GAAG,CAAC;EACvC,IAAIO,YAAY,KAAK,aAAa,EAAE;IAChC,IAAIC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACvCC,OAAO,CAACC,KAAK,CAAE,uBAAsBZ,GAAI,uBAAsB,CAAC;IACpE;IACA,OAAOa,SAAS;EACpB;EACA,OAAOb,GAAG;AACd;AACA;AACA;AACA;AACA;AACA,OAAO,SAASc,mBAAmB,CAACd,GAAG,EAAE;EACrC,OAAOM,qBAAqB,CAACN,GAAG,CAAC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASe,wBAAwB,CAACf,GAAG,EAAE;EAC1C,MAAMO,YAAY,GAAGR,aAAa,CAACC,GAAG,CAAC;EACvC,IAAIO,YAAY,KAAKM,SAAS,IAC1BR,eAAe,CAACW,OAAO,CAACT,YAAY,CAACU,WAAW,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE;IAC5D,OAAOjB,GAAG;EACd;EACA,OAAO,yBAAyB;AACpC"},"metadata":{},"sourceType":"module","externalDependencies":[]}